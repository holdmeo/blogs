@GetMapping("/download/{fileName}")
public ResponseEntity<InputStreamResource> downloadFile(@PathVariable String fileName,
                                                        @RequestHeader HttpHeaders headers) throws IOException {
    File file = new File("C:\\Users\\h\\Desktop\\test\\" + fileName);
    if (!file.exists()) {
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);
    }

    long fileLength = file.length();
    List<HttpRange> ranges = headers.getRange();
    if (ranges.isEmpty()) {
        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + file.getName() + "\"")
                .contentLength(fileLength)
                .contentType(MediaType.APPLICATION_OCTET_STREAM)
                .body(null);
    }

    HttpRange range = ranges.get(0);
    long start = range.getRangeStart(fileLength);
    long end = range.getRangeEnd(fileLength);
    long rangeLength = end - start + 1;

    try (InputStream inputStream = new FileInputStream(file)) {
        inputStream.skip(start);
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        byte[] buffer = new byte[1024];
        long bytesRead = 0;
        int read;
        while (bytesRead < rangeLength && (read = inputStream.read(buffer, 0, (int)Math.min(buffer.length, rangeLength - bytesRead))) != -1) {
            baos.write(buffer, 0, read);
            bytesRead += read;
        }
        InputStreamResource resource = new InputStreamResource(new ByteArrayInputStream(baos.toByteArray()));
        return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT)
            .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"" + resource.getFilename() + "\"")
            .header(HttpHeaders.CONTENT_RANGE, "bytes " + start + "-" + end + "/" + fileLength)
            .contentLength(rangeLength)
            .contentType(MediaType.APPLICATION_OCTET_STREAM)
            .body(resource);
    }
}
@GetMapping("/download/{fileName}")
public void downloadFile1(@PathVariable String fileName, @RequestHeader HttpHeaders headers,HttpServletResponse response) throws IOException {
    File file = new File("C:\\Users\\h\\Desktop\\test\\" + fileName);
    if (!file.exists()) {
        response.setStatus(HttpServletResponse.SC_NOT_FOUND);
        return;
    }

    long fileLength = file.length();
    List<HttpRange> ranges = headers.getRange();
    response.setContentType("application/octet-stream");
    response.setHeader("Content-Disposition", "attachment; filename=\"" + file.getName() + "\"");
    if (ranges.isEmpty()) {
        response.setContentLengthLong(fileLength);
    }else {
        HttpRange range = ranges.get(0);
        long start = range.getRangeStart(fileLength);
        long end = range.getRangeEnd(fileLength);
        long rangeLength = end - start + 1;

        response.setStatus(HttpServletResponse.SC_PARTIAL_CONTENT);
        response.setHeader("Content-Range", "bytes " + start + "-" + end + "/" + fileLength);
        response.setContentLengthLong(rangeLength);

        try (InputStream inputStream = new FileInputStream(file);
             OutputStream outStream = response.getOutputStream()) {
            inputStream.skip(start);
            byte[] buffer = new byte[1024];
            long bytesRead = 0;
            int read;
            while (bytesRead < rangeLength && (read = inputStream.read(buffer, 0, (int)Math.min(buffer.length, rangeLength - bytesRead))) != -1) {
                outStream.write(buffer, 0, read);
                bytesRead += read;
            }
        }
    }
}
// 分段大文件下载

<!DOCTYPE html>
<html>
<head>
    <title>File Download</title>
</head>
<body>
    <button onclick="downloadFile()">Download File</button>
    <script>
        const chunkSize = 10 * 1024 * 1024; // 10MB
        const concurrentRequests = 3;

        async function downloadChunk(url, start, end, index, chunks) {
            try {
                const headers = new Headers();
                headers.append('Range', `bytes=${start}-${end}`);
                const response = await fetch(url, {
                    method: 'GET',
                    headers: headers
                });
                if (response.status === 206) {
                    const blob = await response.blob();
                    chunks[index] = blob;
                } else {
                    console.error('File could not be downloaded.');
                    return;
                }
            } catch (error) {
                console.error('Error:', error);
                return;
            }
        }

        const downloadFile = async () => {
            const url = 'http://127.0.0.1:8090/download/123.7z';
            const filename = '123.7z';
            let fileSize = 0;

            // Get the file size
            const getFileSize = async () => {
                const response = await fetch(url, { method: 'HEAD' });
                const contentLength = response.headers.get('content-length');
                return parseInt(contentLength, 10);
            };

            try {
                fileSize = await getFileSize();
            } catch (error) {
                console.error('Failed to get file size:', error);
                return;
            }

            const totalParts = Math.ceil(fileSize / chunkSize);
            let promises = [];
            const chunks = new Array(totalParts);

            for (let index = 0; index < totalParts; index++) {
                const start = index * chunkSize;
                const end = Math.min(start + chunkSize - 1, fileSize - 1);
                promises.push(downloadChunk(url, start, end, index, chunks));
                console.log("Downloading chunk", index);
                if (promises.length >= concurrentRequests) {
                    await Promise.all(promises);
                    promises = [];
                }
            }

            // Wait for the remaining promises to complete
            await Promise.all(promises);

            // Combine chunks and save as a single file
            try {
                const completeBlob = new Blob(chunks);
                const link = document.createElement('a');
                link.href = window.URL.createObjectURL(completeBlob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error combining chunks:', error);
            }
        };
    </script>
</body>
</html>



<!DOCTYPE html>
<html>
<head>
    <title>File Download</title>
</head>
<body>
    <button onclick="downloadFile()">Download File</button>

    <script>
        const chunkSize = 10 * 1024 * 1024; // 10MB
        const concurrentRequests = 3;
        
        async function downloadChunk(url, start, end,index,db) {
         try {
                const headers = new Headers();
                headers.append('Range', `bytes=${start}-${end}`);

                const response = await fetch(url, {
                    method: 'GET',
                    headers: headers
                });

                if (response.status === 206) {
                    const blob = await response.blob();
                    await saveChunkToDB(db, blob, index);
                } else {
                    console.error('File could not be downloaded.');
                    return;
                }
            } catch (error) {
                console.error('Error:', error);
                return;
            }
        
        }

        const openDB = async () => {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open('fileChunksDB', 1);
                request.onupgradeneeded = event => {
                    const db = event.target.result;
                    db.createObjectStore('chunks', { keyPath: 'id' });
                };
                request.onsuccess = event => {
                    resolve(event.target.result);
                };
                request.onerror = event => {
                    reject(event.target.error);
                };
            });
        };

        const saveChunkToDB = async (db, chunk, index) => {
            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['chunks'], 'readwrite');
                const store = transaction.objectStore('chunks');
                const request = store.put({ id: index, chunk: chunk });
                request.onsuccess = () => resolve();
                request.onerror = event => reject(event.target.error);
            });
        };

        const downloadFile = async () => {
            const url = 'http://127.0.0.1:8090/download/123.7z';
            const filename = '123.7z';
            let fileSize = 0;

            // Get the file size
            const getFileSize = async () => {
                const response = await fetch(url, { method: 'HEAD' });
                const contentLength = response.headers.get('content-length');
                return parseInt(contentLength, 10);
            };

            try {
                fileSize = await getFileSize();
            } catch (error) {
                console.error('Failed to get file size:', error);
                return;
            }

            const db = await openDB();
            const totalParts = Math.ceil(fileSize / chunkSize);
            let promises = [];
            for (let index = 0; index < totalParts; index++) {
                const start = index * chunkSize;
                const end = Math.min(start + chunkSize-1, fileSize-1);
                promises.push(downloadChunk(url, start, end,index,db));
                console.log("File",index);
                if (promises.length >= concurrentRequests) {
                    await Promise.all(promises);
                    promises = [];
                }
            }

            // Combine chunks from IndexedDB and save as a single file
            const combineChunksAndSave = async () => {
                const transaction = db.transaction(['chunks'], 'readonly');
                const store = transaction.objectStore('chunks');
                const chunks = [];

                return new Promise((resolve, reject) => {
                    store.openCursor().onsuccess = event => {
                        const cursor = event.target.result;
                        if (cursor) {
                            chunks.push(cursor.value.chunk);
                            cursor.continue();
                        } else {
                            resolve(new Blob(chunks));
                        }
                    };
                    store.openCursor().onerror = event => reject(event.target.error);
                });
            };

            try {
                const completeBlob = await combineChunksAndSave();
                const link = document.createElement('a');
                link.href = window.URL.createObjectURL(completeBlob);
                link.download = filename;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            } catch (error) {
                console.error('Error combining chunks:', error);
            }
        };
    </script>
</body>
</html>



<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>File Upload with Resume</title>
</head>
<body>
    <input type="file" id="fileInput" />
    <button onclick="uploadFile()">Upload</button>
    <div id="progress"></div>

    <script>
        const CHUNK_SIZE = 10 * 1024 * 1024; // 100 MB
        const uploadUrl = "http://127.0.0.1:8090/uploadChunk1"; // 后端上传文件的URL
        const MAX_CONCURRENT_UPLOADS = 20; // 最大并发上传数
        async function uploadFile() {
            const fileInput = document.getElementById('fileInput');
            const file = fileInput.files[0];
            if (!file) {
                alert("Please select a file.");
                return;
            }

            const totalParts = Math.ceil(file.size / CHUNK_SIZE);
            const fileName = file.name;
            const progressDiv = document.getElementById('progress');

            // 获取已上传的进度
            // let uploadedParts = await getUploadedParts(fileName);
            let currentUploads = [];
            for (let partNumber = 0; partNumber < totalParts; partNumber++) {
                // if (uploadedParts.includes(partNumber)) {
                    // updateProgress(progressDiv, partNumber, totalParts);
                    // continue;
                // }

                const start = partNumber * CHUNK_SIZE;
                const end = Math.min(start + CHUNK_SIZE, file.size);
                const chunk = file.slice(start, end);

                const formData = new FormData();
                formData.append("file", chunk);
                formData.append("uid", "5CB0EEF87F563A330B91B0344A2CFC19");
                formData.append("fileName", fileName);
                formData.append("partNumber", partNumber);
                formData.append("totalParts", totalParts);
                uploadChunk(formData, partNumber, totalParts, progressDiv)
                currentUploads.push(partNumber);
                if (currentUploads.length >= MAX_CONCURRENT_UPLOADS) {
                    await Promise.all(currentUploads);
                    currentUploads = [];
                }
            }

            if (currentUploads.length > 0) {
                await Promise.all(currentUploads);
            }
            console.log("File uploaded successfully!");
        }

        async function uploadChunk(formData, partNumber, totalParts, progressDiv) {
            try {
                const response = await fetch(uploadUrl, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    throw new Error(`Failed to upload chunk: ${response.statusText}`);
                }

                const result = await response.text();
                console.log(result);
                updateProgress(progressDiv, partNumber, totalParts);
            } catch (error) {
                console.error(error);
                console.error("Failed to upload chunk");
            }
        }

        function updateProgress(progressDiv, partNumber, totalParts) {
            progressDiv.innerHTML = `Uploaded ${partNumber + 1} of ${totalParts} parts.`;
        }

        async function getUploadedParts(fileName) {
            // 这里可以从后端获取已上传的分片信息，以确定哪些分片已经上传
            const response = await fetch(`/upload/progress?fileName=${encodeURIComponent(fileName)}`);
            if (response.ok) {
                const data = await response.json();
                return data.uploadedParts || [];
            } else {
                return [];
            }
        }
    </script>
</body>
</html>

@PostMapping("/uploadChunk")
public RestObject uploadChunk(@RequestParam("file") MultipartFile file,
                               @RequestParam("uid") String uid,
                               @RequestParam("fileName") String fileName,
                               @RequestParam("partNumber") int partNumber,
                               @RequestParam("totalParts") int totalParts) {

    String redisKey = "file:progress:" + uid;
    String uploadDir = "C:\\Users\\h\\Desktop\\test\\"+uid;
    boolean exist=redisService.hasKey(redisKey);
    if (!exist){
        // 初始化进度信息
        StringBuilder initialProgress = new StringBuilder();
        for (int i = 0; i < totalParts; i++) {
            initialProgress.append('0');
        }
        redisService.set(redisKey, initialProgress.toString());
        redisService.expire(redisKey, 1, TimeUnit.DAYS); // 设置过期时间为1天
    }

    String progress = String.valueOf(redisService.get(redisKey));
    if (progress.charAt(partNumber) == '1') {
        return new RestObject(201,"分片文件" + partNumber + "已经上传");
    }
    //服务器中文件不存在，就创建配置文件中的文件夹
    File[] files = new File(uploadDir).listFiles();
    if (files == null) {
        new File(uploadDir).mkdirs();
    }
    File uploadFile = new File(uploadDir,fileName);;
    try (RandomAccessFile raf = new RandomAccessFile(uploadFile, "rw")) {

        raf.seek(partNumber * PART_SIZE);
        raf.write(file.getBytes());

        StringBuilder updatedProgress = setProgress(redisKey,partNumber);
        boolean uploadComplete = updatedProgress.indexOf("0") == -1;

        if (uploadComplete) {
            redisService.del(redisKey);
            return RestObject.newOk("文件上传完成");
        }
        return new RestObject(201,"分片文件" + partNumber + " 上传完成");
    } catch (IOException e) {
        e.printStackTrace();
        return RestObject.newError("文件上传失败！");
    }
}
private synchronized StringBuilder setProgress(String redisKey, int partNumber){
    String progress = String.valueOf(redisService.get(redisKey));
    StringBuilder updatedProgress = new StringBuilder(progress);
    updatedProgress.setCharAt(partNumber, '1');
    redisService.set(redisKey, updatedProgress.toString());
    return updatedProgress;
}
redis 分布式事务

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.data.redis.core.script.DefaultRedisScript;
import org.springframework.stereotype.Service;

import java.util.Collections;
import java.util.concurrent.TimeUnit;

@Service
public class RedisLockService {

    @Autowired
    private StringRedisTemplate redisTemplate;

    @Autowired
    private DefaultRedisScript<Long> lockScript;

    @Autowired
    private DefaultRedisScript<Long> unlockScript;

    // 获取锁
    public boolean tryLock(String key, String value, long timeout, TimeUnit unit) {
        long milliseconds = unit.toMillis(timeout);
        Long result = redisTemplate.execute(lockScript, Collections.singletonList(key), value, String.valueOf(milliseconds));
        return result != null && result == 1;
    }

    // 释放锁
    public boolean unlock(String key, String value) {
        Long result = redisTemplate.execute(unlockScript, Collections.singletonList(key), value);
        return result != null && result == 1;
    }

    @Bean
    public DefaultRedisScript<Long> lockScript() {
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(
                "if redis.call('setnx', KEYS[1], ARGV[1]) == 1 then " +
                        "return redis.call('pexpire', KEYS[1], ARGV[2]) " +
                        "else return 0 end");
        redisScript.setResultType(Long.class);
        return redisScript;
    }

    @Bean
    public DefaultRedisScript<Long> unlockScript() {
        DefaultRedisScript<Long> redisScript = new DefaultRedisScript<>();
        redisScript.setScriptText(
                "if redis.call('get', KEYS[1]) == ARGV[1] then " +
                        "return redis.call('del', KEYS[1]) " +
                        "else return 0 end");
        redisScript.setResultType(Long.class);
        return redisScript;
    }
}
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.stereotype.Service;
import java.util.concurrent.TimeUnit;

@Service
public class MyService {

    @Autowired
    private RedisLockService redisLockService;

    @Autowired
    private StringRedisTemplate redisTemplate;

    public void updateValue(String id, String newValue) {
        String lockKey = "lock:" + id;
        String lockValue = String.valueOf(System.currentTimeMillis() + 10000); // 设置一个超时时间，防止死锁
        try {
            if (redisLockService.tryLock(lockKey, lockValue, 10, TimeUnit.SECONDS)) {
                // 加锁成功，进行处理
                redisTemplate.opsForValue().set(id, newValue);
            } else {
                // 获取锁失败，说明其他线程正在修改
                throw new RuntimeException("Failed to acquire lock");
            }
        } finally {
            // 释放锁
            redisLockService.unlock(lockKey, lockValue);
        }
    }
}
 echotsFunc(param) {
    let e = echarts.init(document.getElementById(param.elementId));// 确保图表适应容器大小
    let max = 1;
    let min = 0;

    if (param.mixData.length > 0) {
      max = Math.max(...param.mixData);
    }

    const pow = (Math.round(max / 8) + "").length - 1;
    const pow_ten = Math.pow(10, pow);
    max =
      max < Math.ceil(max / (pow_ten * 4)) * pow_ten * 4 * 0.95
        ? max
        : max / 0.95;
    let interval = Math.ceil(Math.ceil(max / pow_ten) / 4) * pow_ten;
    interval = interval === 0 ? 1 : interval;
    if (interval < 1) {
      interval = 1;
    }
    max = 1;  // For binary status 0 and 1, max is fixed to 1

    // 确定图表的最小和最大日期范围
    const currentDate = new Date();
    const minDate = new Date(currentDate.setHours(0, 0, 0, 0));  // 当天的0点
    const maxDate = new Date(currentDate.setHours(24, 0, 0, 0)); // 当天的24点（实际上是下一天的0点）

    const series = param.yDatas.map((y) => {
      return {
        name: y.name,
        type: "line",
        step: 'end',
        data: param.yDatas[0].data.map(point => [point[0], point[1] === 1 ? 1 : 0]),
        symbol: "circle",
        symbolSize: 4,
        itemStyle: {
          color: y.color,
          borderColor: "#fff",
        },
        lineStyle: {
          color: y.color,
          type: "solid",
        },
        areaStyle: {
          color: {
            type: "linear",
            x: 0,
            y: 0,
            x2: 0,
            y2: 1,
            colorStops: [
              {
                offset: 0,
                color: y.color,
              },
              {
                offset: 1,
                color: y.color + "00",
              },
            ],
            global: false,
          },
        },
        silent: true,
        emphasis: {
          disabled: true,
        },
      };
    });

    const option = {
      grid: {
        top: 60,
        bottom: 50,
        left: 50,
        right: 50,
        containLabel: true,
      },
      tooltip: {
        trigger: "axis",
        axisPointer: {
          type: "line",
        },
        backgroundColor: "rgba(50,50,50,0.7)",
        borderWidth: 0,
        textStyle: {
          color: "#fff",
          fontSize: 12,
        },
      },
      legend: {
        show: true,
        top: 14,
        right: 15,
        itemGap: 20,
        itemWidth: 52,
        itemHeight: 26,
        itemStyle: {
          shadowColor: "rgba(0,0,0,0.1)",
          shadowOffsetX: 0,
          shadowOffsetY: 2,
          shadowBlur: 5,
        },
        data: param.yDatas.map((item) => item.name),
        textStyle: {
          rich: {
            a: {
              color: "#666",
              fontSize: 20,
              lineHeight: 26,
              verticalAlign: "top",
            },
          },
        },
        formatter: (name) => {
          return `{a|${name}}`;
        },
      },
      xAxis: {
        type: "time",
        min: minDate.getTime(),
        max: maxDate.getTime(),
        axisLabel: {
          formatter: function (value) {
            const date = new Date(value);
            const hours = date.getHours();
            const day = date.getDate();
            if (hours === 0 && day !== minDate.getDate()) {
              return `24:00`;  // 将下一天的0点显示为今天的24:00
            } else if ([0, 12, 24].includes(hours)) {
              return `${hours}:00`;
            }
            return '';
          },
          showMinLabel: true,
          showMaxLabel: true,
          textStyle: {
            color: "#666",
            fontSize: 12,
          },
        },
        splitLine: {
          show: false,
          interval: (index, value) => {
            const hours = new Date(value).getHours();
            return [0, 12, 24].includes(hours);
          }
        },
        axisTick: {
          alignWithLabel: true,
          interval: (index, value) => {
            const hours = new Date(value).getHours();
            return [0, 12, 24].includes(hours);
          }
        },
        axisLine: {
          lineStyle: {
            color: "#ccc",
          },
        },
      },
      yAxis: {
        type: "value",
        min: 0,
        max: 1,
        interval: 1,
        axisLabel: {
          formatter: function (value) {
            return value === 0 ? "停机" : "开机";
          },
          textStyle: {
            color: "#666",
            fontSize: 12,
            padding: [10, 0, 0, -10], // 上、右、下、左的padding，调整字体相对于Y轴的位置
            verticalAlign: "middle", // 垂直对齐
            align: "center", // 水平对齐
          },
        },
        splitLine: {
          lineStyle: {
            type: "dashed",
            color: "#EBEBEB",
          },
        },
      },
      series: series,
    };
    e.setOption(option);
    window.addEventListener("resize", function () {
      e && e.resize && e.resize();
    });
  },

const testData = {
        elementId: "device_base_info_winding_echarts",
        yDatas: [
        {
            name: "状态",
            type: "line",
            color: "#00BDAA",
            data: [
            ["2024-09-03 00:00:00", 1],
            ["2024-09-03 23:20:11", 0],
            ["2024-09-03 23:20:51", 1],
            ],
        },
        ],
        mixData: [1, 0, 1, 1, 0],
        };



1. 下载 OpenSSL 源码

访问官方 OpenSSL 源码页面下载最新版（推荐 LTS 版本，例如 1.1.1 系列）：
https://www.openssl.org/source/

例如下载 openssl.tar.gz，将其放到指定目录，例如 /usr/local 

2. 解压和准备安装

# 进入存放源码的目录
cd /usr/local

# 解压源码包
tar -xzf openssl.tar.gz
cd openssl

3. 配置编译参数

确保安装到独立目录，例如 /usr/local/openssl，避免覆盖系统默认的 OpenSSL。

# 配置编译路径，避免影响系统的 OpenSSL
./config --prefix=/usr/local/openssl --openssldir=/usr/local/openssl shared zlib

参数说明:
    •    --prefix：指定安装路径。
    •    --openssldir：指定 OpenSSL 配置文件路径。
    •    shared：启用共享库。
    •    zlib：启用 zlib 压缩支持。

4. 编译和安装

# 编译
make -j$(nproc)  # 使用多核并行加速编译

# 安装
make install

安装完成后，OpenSSL 会被安装到 /usr/local/openssl。

5. 配置环境变量

为了让新版本的 OpenSSL 与系统默认版本共存，临时或永久配置环境变量：

临时设置（仅当前会话）

export PATH=/usr/local/openssl/bin:$PATH
export LD_LIBRARY_PATH=/usr/local/openssl/lib64:$LD_LIBRARY_PATH

永久设置

将以下内容添加到 /etc/profile 或用户的 ~/.bashrc：

echo "export PATH=/usr/local/openssl/bin:\$PATH" >> /etc/profile
echo "export LD_LIBRARY_PATH=/usr/local/openssl/lib64:\$LD_LIBRARY_PATH" >> /etc/profile
source /etc/profile

6. 验证安装

执行以下命令验证安装的新版本：

openssl version

如果输出类似以下内容，则说明新版本安装成功：

OpenSSL 1.1.1s  1 Nov 2022

Python安装：

下载与您当前 Python 版本相匹配的源码。例如：

wget https://www.python.org/ftp/python/3.8.12/Python-3.8.12.tgz
tar -zxvf Python-3.8.12.tgz
cd Python-3.8.12

配置并编译
./configure --enable-optimizations --prefix=/opt/python3 --with-openssl=/usr/local/openssl LDFLAGS="-L/usr/local/openssl/lib64" CPPFLAGS="-I/usr/local/openssl/include"
make -j$(nproc)
sudo make altinstall

参数说明：
•    --enable-optimizations：启用优化，提高性能。
•    --with-openssl=/usr/local/openssl：指定 OpenSSL 路径（默认路径为 /usr/local/openssl）。
注意：使用 make altinstall 而不是 make install，可以避免将 Python3 的默认命令设置为 python，从而保护系统的其他 Python 版本。


配置环境变量,确保可以通过命令行访问新安装的 Python3：
添加新版本 Python3 的路径到环境变量：

echo 'export PATH=/opt/python3/bin:$PATH' >> ~/.bashrc
source ~/.bashrc

验证安装：

python3.8 --version


8. 验证 Python 使用的 OpenSSL 版本

运行以下命令检查 Python 是否链接到新的 OpenSSL：

python3.8 -c "import ssl; print(ssl.OPENSSL_VERSION)"

如果输出是新版本 OpenSSL 1.1.1s，则配置成功。

/data/test/jdk-17/bin/java -jar /data/test/jenkins.war --httpPort=2080

D:\java\jdk-17\bin\java -jar D:\app\jenkins.war --httpPort=2080

ssh root@192.168.0.0.1 -p 22

ssh-copy-id root@192.168.0.0.1 -p 22

SZpmcc*1430


要在 Windows 上运行的 Jenkins 实现对 Linux 服务器的 JAR 包一键部署，您可以按照以下步骤进行配置：

1. 在 Jenkins 服务器上配置 SSH 客户端

由于 Jenkins 运行在 Windows 上，需要确保 Windows 系统具备 SSH 客户端功能，以便通过 SSH 与 Linux 服务器通信。
    1.    安装 OpenSSH 客户端：
    •    在 Windows 10 或更高版本中，您可以通过以下步骤安装 OpenSSH 客户端：
    •    打开“设置” > “应用” > “可选功能”。
    •    点击“添加功能”，在列表中找到“OpenSSH 客户端”，然后点击“安装”。
    •    安装完成后，您可以在命令提示符或 PowerShell 中使用 ssh 和 scp 命令。
    2.    生成 SSH 密钥对：
    •    打开 PowerShell 或命令提示符，运行以下命令生成 SSH 密钥对：
        ssh-keygen -t rsa -b 2048 -C "jenkins@yourdomain.com"

    •    按提示操作，生成的密钥对默认存储在 C:\Users\YourUsername\.ssh\ 目录下。

    3.    将公钥添加到远程 Linux 服务器：
    •    配置 vim /etc/ssh/sshd_config ,修改后重启sudo systemctl restart sshd：
        PubkeyAuthentication yes       
        AuthorizedKeysFile .ssh/authorized_keys  
        PasswordAuthentication yes
    •    使用以下命令将公钥复制到远程 Linux 服务器的 ~/.ssh/authorized_keys 文件中：
        ssh-copy-id -i C:\Users\YourUsername\.ssh\id_rsa.pub user@remote_server_ip

    •    如果 ssh-copy-id 不可用，可以手动将公钥内容追加到远程服务器的 ~/.ssh/authorized_keys 文件中。
        echo "公钥内容" >> ~/.ssh/authorized_keys

2. 在 Jenkins 中配置 SSH 凭据
    1.    添加 SSH 凭据：
    •    登录 Jenkins，进入“系统管理” > “管理凭据”。
    •    在“全局凭据”下，点击“添加凭据”。
    •    类型选择“SSH Username with private key”。
    •    配置用户名（与远程服务器的用户名一致）和对应的私钥路径（例如 C:\Users\YourUsername\.ssh\id_rsa）。

3. 配置 Jenkins Pipeline 实现一键部署
    •    将 DEPLOY_SERVERS 替换为实际的目标服务器 IP 列表。
    •    将 SSH_CREDENTIALS_ID 替换为在 Jenkins 中配置的 SSH 凭据 ID。
    •    user 替换为远程服务器的实际用户名。
    •    确保 JAR 包构建后存放在 target\myapp.jar 路径下，或根据实际情况修改路径。
    •    执行指令: sshagent 在windows中使用bat ,Linux系统中使用 sh。
    

部署步骤
    1.    上传所需插件到 Jenkins：
    •    进入 Jenkins，依次点击“系统管理” > “管理插件” > “高级” > “上传插件”，上传所需插件。
    2.    配置 SSH 凭据：
    •    确保所有目标服务器的 SSH 信息已正确配置，并在 Jenkinsfile 中引用配置的凭据 ID。
    3.    创建 Pipeline 项目：
    •    创建一个新的 Pipeline 项目，并将上述 Jenkinsfile 配置为项目脚本。
    4.    运行 Pipeline：
    •    启动任务，Jenkins 将会自动完成文件上传和 JAR 包运行。以下是示例 Jenkinsfile，用于

winddows构建并部署 JAR 包到多台 Linux 服务器：
pipeline {
    agent any
    environment {
        SSH_CREDENTIALS_ID = '9495eab3-13c6-4d8c-b2c2-984becdbe37f'
    }
    stages {
        stage('Build') {
            steps {
                echo "构建 JAR 包..."
            }
        }
        stage('Upload JAR to Servers') {
            steps {
                script {
                    def servers = ['root@192.168.0.0.1 -p 22']
                    servers.each { server ->
                        withCredentials([sshUserPrivateKey(credentialsId: '9495eab3-13c6-4d8c-b2c2-984becdbe37f', keyFileVariable: 'SSH_KEY')]) {
                            bat """
                            ssh -i %SSH_KEY% root@192.168.0.0.1 -p 22 "echo 'Connected via SSH!'"
                            """
                        }
                    }
                }
            }
        }
    }
}

//linux 系统并行
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo "开始运行部署..."
            }
        }
        stage('Upload JAR to Servers and Execute Script') {
            steps {
                script {
                    def servers = [
                        [userhost: 'root@192.168.0.0.1',port: '22']
                    ]
                    def batchSize = 10
                    def deployJobs = [:]
                    def credentials = ['d956528d-293a-446c-b9a9-26936838b892']
                    servers.collate(batchSize).eachWithIndex { batch, index ->
                        deployJobs["Batch ${index + 1}"] = {
                            batch.each { server ->
                                try {
                                    sshagent(credentials) {
                                        scp -P  ${server.port} 111.jar ${server.userhost}:/data/test
                                        ssh ${server.uhost} -p ${server.port} sh /data/test/restart_szdh.sh
                                    }
                                } catch (Exception e) {
                                    echo "Deployment to ${server.userhost} failed: ${e.getMessage()}"
                                }
                            }
                        }
                    }
                    parallel deployJobs
                }
            }
        }
    }
}

要在多台服务器上通过 Jenkins 实现 JAR 包的一键部署，需要以下配置和插件支持：

1. 必要的插件
    1.    SSH Pipeline Steps Plugin
    •    允许通过 SSH 在远程服务器上执行命令。
    •    下载地址: SSH Pipeline Steps Plugin
    •    文件名：ssh-steps.hpi
    2.    Publish Over SSH Plugin
    •    允许将文件通过 SSH 传输到远程服务器。
    •    下载地址: Publish Over SSH Plugin
    •    文件名：publish-over-ssh.hpi
    3.    Pipeline Plugin (必须)
    •    提供 Jenkinsfile 支持，用于配置流水线任务。
    •    下载地址: Pipeline Plugin
    •    文件名：workflow-aggregator.hpi
    4.    Git Plugin (可选)
    •    如果您的 JAR 包存储在 Git 仓库中，需用该插件来拉取代码。
    •    下载地址: Git Plugin
    •    文件名：git.hpi

2. 环境准备
    1.    Jenkins 配置 SSH 凭据
    •    登录 Jenkins，进入 Manage Jenkins > Manage Credentials。
    •    添加 SSH 类型的凭据，包括目标服务器的用户名和私钥。
    2.    远程服务器配置
    •    确保远程服务器已安装 JDK 和配置 JAVA_HOME 环境变量。
    •    确保远程服务器支持 SSH 登录，并允许 Jenkins 用户通过公私钥验证。

3. 配置 Jenkins Pipeline 实现一键部署

示例 Jenkinsfile

将以下脚本保存为 Jenkinsfile，并在 Jenkins 的 Pipeline 项目中使用：
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                echo "Simulating JAR build process..."
            }
        }
        stage('Upload and Execute Script') {
            steps {
                script {
                    def servers = [
                        [name: '192.168.0.0.1']
                    ]
                    servers.each { server ->
                        sshPublisher(publishers: [
                            sshPublisherDesc(
                                configName: server.name,
                                transfers: [
                                    sshTransfer(
                                        sourceFiles: '111.jar', 
                                        remoteDirectory: '//data/test', 
                                        execCommand: 'sh /data/test/restart.sh',
                                        removePrefix: ''
                                    )
                                ],
                                usePromotionTimestamp: false,
                                verbose: true
                            )
                        ])
                    }
                }
            }
        }
    }
}
4. 部署步骤
    1.    上传插件到 Jenkins
    •    进入 Jenkins，Manage Jenkins > Manage Plugins > Advanced > Upload Plugin，上传所需插件。
    2.    配置 SSH 凭据
    •    确保所有目标服务器的 SSH 信息已正确配置，并在 Jenkinsfile 中引用配置名称。
    3.    创建 Pipeline 项目
    •    创建一个新的 Pipeline 项目，并将上述 Jenkinsfile 配置为项目脚本。
    4.    运行 Pipeline
    •    启动任务，Jenkins 将会自动完成文件上传和 JAR 包运行。

如需进一步帮助，请随时提问！

windows启动rocketmq的bat文件：
@echo off
set ROCKETMQ_HOME=C:\app\rocketmq-4.9.7

REM 启动NameServer
echo Starting NameServer...
start "NameServer" /B %ROCKETMQ_HOME%\bin\mqnamesrv.cmd

REM 等待NameServer启动完成
ping -n 5 127.0.0.1 > nul

REM 启动Broker
echo Starting Broker...
start "Broker" /B %ROCKETMQ_HOME%\bin\mqbroker.cmd -n 127.0.0.1:9876 -c %ROCKETMQ_HOME%\conf\broker.conf autoCreateTopicEnable=true

echo RocketMQ started successfully!

测试状态发送和接收消息：
./mqadmin consumerStatus -n 127.0.0.1:9876 -g consumeGroup

./mqadmin sendMessage -n 127.0.0.1:9876 -t testChannel -p "Hello RocketMQ"

./mqadmin consumeMessage -n "127.0.0.1:9876" -t testChannel -g consumeGroup -c 10


// 动态定时任务
public class ScheduledTaskManage {

    private Map<String, ScheduledFuture<?>> scheduledTasks = new ConcurrentHashMap<>();
    
    public void createTask(String taskName, String cronExpression) {
        try {
            if (scheduledTasks.containsKey(taskName)) {
                scheduledTasks.get(taskName).cancel(false);
            }
            Runnable task = () -> excuteTask(taskName);
            ScheduledFuture<?> future = taskScheduler.schedule(task, new CronTrigger(cronExpression));
            scheduledTasks.put(taskName, future);
        } catch (Exception e) {
            log.error("创建定时任务异常：",taskName);
        }
    }
    
    
    public void removeTask(String taskName) {
        if (scheduledTasks.containsKey(taskName)) {
            scheduledTasks.get(taskName).cancel(false);
            scheduledTasks.remove(taskName);
        }
    }
}



public class TemplateResolvUtil {
    public static JSONObject getKeyValues(String template, String jsonValues) {
        template = getJsonTemplate(template);
        // Parse the actual values manually into a Map
        Map<String, String> values = parseJsonValues(jsonValues);
        // Pattern to find the placeholders in the template
        Pattern pattern = Pattern.compile("\\$\\{(\\w+(:\\w+)?(:\\w+)?(:\\w+)?)\\}");
        Matcher matcher = pattern.matcher(template);

        // Buffer to store the final string
        List<String> placeholderList=new ArrayList();
        while (matcher.find()) {
            String placeholder = matcher.group(1); // Extract the placeholder name without ${}
            placeholderList.add(placeholder);
        }

        Map<String, String> placeholderToActualKey=findActualKey(template, placeholderList,values.size());
        JSONObject jsonObject = new JSONObject();
        for (Map.Entry<String, String> entry : placeholderToActualKey.entrySet()) {
            String[] key = entry.getKey().split(":", 4);
            if (key.length == 4) {
                if (key[1].equals(values.get(entry.getValue()))) {
                    jsonObject.put(key[0],key[2]);
                }else {
                    jsonObject.put(key[0],key[3]);
                }
            }else {
                jsonObject.put(entry.getKey(),values.get(entry.getValue()));
            }
        }
        return jsonObject;
    }

    private static Map<String, String> parseJsonValues(String jsonValues) {
        Map<String, String> valuesMap = new HashMap<>();

        // Remove the curly braces and split the string by commas, handle nested structure
        String cleanedJsonValues = jsonValues.replaceAll("[{}\\[\\]]", "").trim();
        String[] keyValuePairs = cleanedJsonValues.split(",(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)");

        // Iterate over the key-value pairs
        for (int i = 0; i <keyValuePairs.length ; i++) {
            // Split the pair by the colon
            String[] entry = keyValuePairs[i].split(":", 3);
            if (entry.length == 2) {
                // Remove quotes and trim spaces
                String key = entry[0].replaceAll("\"", "").trim();
                String value = entry[1].replaceAll("\"", "").trim();
                if (valuesMap.containsKey(key)){
                    log.info("字段重复，可能出现取值有误的情况：{}",key);
                }
                valuesMap.put(key, value);
            }else if (entry.length == 3){
                String key = entry[1].replaceAll("\"", "").trim();
                String value = entry[2].replaceAll("\"", "").trim();
                if (valuesMap.containsKey(key)){
                    log.info("字段重复，可能出现取值有误的情况：{}",key);
                }
                valuesMap.put(key, value);
            }
        }
        return valuesMap;
    }


    private static Map<String, String> findActualKey(String template, List<String> placeholderList, int size) {
        // Pattern to find the actual key corresponding to the placeholder
        String cleanedJsonValues = template.replaceAll("[{}\\[\\]]", "").trim();
        String[] keyValuePairs = cleanedJsonValues.split(",(?=([^\\\"]*\\\"[^\\\"]*\\\")*[^\\\"]*$)");
//        if (size!=keyValuePairs.length){
//            throw new RuntimeException("模板和结果字段不匹配");
//        }
        Map<String, String> placeholderToActualKey = new HashMap<>();
        for (int i = 0; i <keyValuePairs.length ; i++) {
            String keyValuePair = keyValuePairs[i];
            for (String placeholder:placeholderList ) {
                Pattern pattern = Pattern.compile("\"(\\w+)\": \\$" + placeholder);
                Matcher matcher = pattern.matcher(keyValuePair);
                if (matcher.find()) {
                    placeholderToActualKey.put(placeholder, matcher.group(1));
                }
            }
        }
        return placeholderToActualKey;
    }

    public static List<String> extractPlaceholders(String template) {
        List<String> placeholders = new ArrayList<>();
        // 定义正则表达式匹配${}
        Pattern pattern = Pattern.compile("\\$\\{(.*?)}");
        Matcher matcher = pattern.matcher(template);

        // 找到所有${}中的键
        while (matcher.find()) {
            placeholders.add(matcher.group(1));
        }
        return placeholders;
    }

    public static String replacePlaceholders(String template, Map<String, String> values) {
        for (Map.Entry<String, String> entry : values.entrySet()) {
            String placeholder = "${" + entry.getKey() + "}";
            template = template.replace(placeholder, entry.getValue());
        }
        return template;
    }

    public static String getJsonTemplate(String template) {
        if (template.startsWith("\"")){
            template=template.replaceFirst("\"","");
        }
        if (template.endsWith("\"")){
            template=template.replaceFirst("\"$","");
        }
        String jsonString = template.replace("\\\"", "\"")
                .replace("\\n", "\n")
                .replace("\\t", "\t")
                .replace("n\t", "")
                .replace("\\", "");
        return jsonString;
    }

    public static Map<String, String> extractCredentials(String rtspUrl) {
        Map<String, String> result = new HashMap<>();
        if (rtspUrl == null || rtspUrl.isEmpty()) {
            result.put("username", "");
            result.put("password", "");
            return result;
        }

        // 匹配用户名和密码：rtsp://用户名:密码@
        Pattern pattern = Pattern.compile("rtsp://(.*?):(.*?)@");
        Matcher matcher = pattern.matcher(rtspUrl);
        if (matcher.find()) {
            result.put("username", matcher.group(1));
            result.put("password", matcher.group(2));
        } else {
            result.put("username", "");
            result.put("password", "");
        }
        return result;
    }
    
    public String getReplaceParmas(String params,JSONArray jsonArray) {
        // 构建正则
        Pattern pattern = Pattern.compile("\\$\\[(.+?)\\]\\$");
        Matcher matcherTemplate = pattern.matcher(params);
        StringBuffer sb = new StringBuffer();
        while (matcherTemplate.find()) {
            matcherTemplate.appendReplacement(sb, Matcher.quoteReplacement(jsonArray.toJSONString()));
        }
        matcherTemplate.appendTail(sb);
        return sb.toString();
    }

    public static void main(String[] args) {
        Map<String, String> values= null;
        List<String> placeholders = null;
        String jsonString = "{\"url\":${URL_ADDR},\"type\":\"2\"}";
        values = new HashMap<>();
        placeholders = extractPlaceholders(jsonString);
        for (String key:placeholders) {
            if ("URL_ADDR".equals(key)){
                values.put(""+key+"","\""+"http://127.0.0.1"+"\"");
            }else {
                values.put(""+key+"","\"\"");
            }
        }
        JSONObject params = JSON.parseObject(replacePlaceholders(jsonString, values));
        System.out.println(params);
    }
}



// ping 工具类

public final class PingUtils {

    Logger log = LoggerFactory.getLogger(PingUtils.class);

    public static String ping(String ip) {
        // 根据操作系统选择命令
        String command = System.getProperty("os.name").startsWith("Windows")
                ? "ping -n 1 -w 1000 " + ip // Windows: 超时设置 1秒
                : (ip.contains(":")
                ? "ping6 -c 1 -W 1 " + ip // Linux IPv6
                : "ping -c 1 -W 1 " + ip); // Linux IPv4

        // 使用 ExecutorService 执行命令并限制时间
        ExecutorService executor = Executors.newSingleThreadExecutor();
        Future<String> future = executor.submit(() -> executeCommand(command));

        try {
            // 限制执行时间为1秒
            String result = future.get(1, TimeUnit.SECONDS);
            if (isReachable(result)) {
                return "200";
            }
        } catch (TimeoutException e) {

        } catch (Exception e) {
            log.info("执行命令错误，Command: " + command, e);
        } finally {
            executor.shutdown();
        }
        return "500";
    }


    /**
     * 执行命令并解决中文乱码问题
     *
     * @param command 要执行的命令
     * @return 命令输出结果
     * @throws Exception 执行过程中的异常
     */
    private static String executeCommand(String command) throws Exception {
        StringBuilder result = new StringBuilder();
        Process process = Runtime.getRuntime().exec(command);

        // 根据系统编码读取输出
        Charset charset = System.getProperty("os.name").startsWith("Windows") ? Charset.forName("GBK") : Charset.defaultCharset();

        try (BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream(), charset))) {
            String line;
            while ((line = reader.readLine()) != null) {
                result.append(line).append("\n");
            }
            process.waitFor();
        }
        return result.toString();
    }

    /**
     * 判断 ping 的输出是否表明 IP 是通的
     *
     * @param result ping 命令的输出
     * @return true 表示通，false 表示不通
     */
    private static boolean isReachable(String result) {
        result = result.toLowerCase(); // 忽略大小写
        // Windows/Linux 通用标志
        return result.contains("ttl")
                || result.contains("bytes from") // Linux 成功标志
                || result.contains("icmp_seq") // IPv6 Linux 成功标志
                || result.contains("已接收 = 1") // Windows IPv6 成功标志（中文）
                || result.contains("received = 1"); // Windows IPv6 成功标志（英文）
    }

    public static void main(String[] args) {
        String ip ="fe80::796d:5678:baef:3d18";
        System.out.println(ping(ip));;
    }
}



// -----------------------mqtt 封装----------------------------

import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.ArrayUtils;
import org.eclipse.paho.client.mqttv3.*;
import org.eclipse.paho.client.mqttv3.persist.MemoryPersistence;
import org.springframework.integration.mqtt.support.MqttMessageConverter;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHandler;

import java.util.Arrays;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;

@Slf4j
public class MqttConnectionManagerTest {

    private volatile AtomicBoolean reconnectFlag = new AtomicBoolean(false);
    private volatile IMqttClient mqttClient;
    private MqttConnectOptions mqttConnectOptions;
    //    private MqttPahoClientFactory mqttPahoClientFactory;
    private String serverUrls;
    private String clientId;
    private MqttMessageConverter mqttMessageConverter;
    private MessageHandler messageHandler;
    private int qos = 1;
    private String[] topics;
    private int[] currentQos;
    private IMqttMessageListener[] currentListeners;

    private MqttConnectionManagerTest() {
    }


    public MqttConnectionManagerTest connectAndSubscribe(String[] topics, MessageHandler messageHandler) {
        try {
            if (mqttClient == null) {
                mqttClient = new MqttClient(serverUrls, clientId, new MemoryPersistence());
            }
            mqttClient.setCallback(new MqttCallbackExtended() {
                @Override
                public void connectComplete(boolean reconnect, String serverURI) {
                    log.info("自动连接完成，待订阅: reconnect={}, server={}", reconnect, serverURI);
                }

                @Override
                public void connectionLost(Throwable cause) {
                    log.warn("连接丢失: {}", cause.getMessage(), cause);
                    reconnectByTask();
                }

                @Override
                public void messageArrived(String topic, MqttMessage mqttMessage) {
                    Message message = mqttMessageConverter.toMessage(topic, mqttMessage);
                    try {
                        messageHandler.handleMessage(message);
                    } catch (Exception e) {
                        log.error("消息处理失败", e);
                    }
                }

                @Override
                public void deliveryComplete(IMqttDeliveryToken token) {}
            });

            if (!mqttClient.isConnected()) {
                try {
                    mqttClient.connect(mqttConnectOptions);
                } catch (MqttException e) {
                    log.warn("初始连接失败，等待自动重连", e);
                }
            }

            if (ArrayUtils.isEmpty(topics)) {
                return this;
            }

            this.topics = topics;
            currentQos = new int[topics.length];
            Arrays.fill(currentQos, qos);

            currentListeners = new IMqttMessageListener[topics.length];
            IMqttMessageListener sharedListener = (topic, mqttMessage) -> {
                Message message = mqttMessageConverter.toMessage(topic, mqttMessage);
                try {
                    messageHandler.handleMessage(message);
                } catch (RuntimeException e) {
                    log.error("Mqtt connectAndSubscribe handleMessage error", e);
                    throw e;
                }
            };
            Arrays.fill(currentListeners, sharedListener);

            mqttClient.subscribe(topics, currentQos, currentListeners);
            log.info("连接并订阅成功: {}", Arrays.toString(topics));
        } catch (Exception e) {
            log.error("connectAndSubscribe 异常", e);
        }

        return this;
    }

    private void reconnectByTask() {
        log.info("开始手动重连并订阅");
        reconnectFlag.set(true);
        final ScheduledExecutorService scheduler = Executors.newSingleThreadScheduledExecutor();
        final int[] retries = {0};

        scheduler.scheduleAtFixedRate(() -> {
            if (mqttClient.isConnected()) {
                scheduler.shutdown();
                return;
            }

            try {
                mqttClient.connect(mqttConnectOptions);
                mqttClient.subscribe(topics, currentQos, currentListeners);
                reconnectFlag.set(false);
                log.info("重连成功并重新订阅");
                scheduler.shutdown();
            } catch (Exception e) {
                retries[0]++;
                log.warn("重连失败，重试第 {} 次: {}", retries[0], e.getMessage());
               /* if (retries[0] >= 10) { // 最多尝试 10 次
                    log.error("重连尝试次数过多，停止尝试");
                    scheduler.shutdown();
                }*/
            }
        }, 0, 10, TimeUnit.SECONDS); // 每 5 秒重试一次
    }
}


import lombok.extern.slf4j.Slf4j;
import org.apache.commons.lang3.StringUtils;
import org.springframework.beans.BeansException;
import org.springframework.context.ApplicationContext;
import org.springframework.context.ApplicationContextAware;
import org.springframework.context.ApplicationListener;
import org.springframework.context.event.ContextClosedEvent;
import org.springframework.integration.mqtt.support.MqttHeaders;
import org.springframework.messaging.Message;
import org.springframework.messaging.MessageHandler;
import org.springframework.messaging.MessageHeaders;
import org.springframework.messaging.MessagingException;
import org.springframework.stereotype.Component;

import java.util.Map;
import java.util.Objects;
import java.util.concurrent.*;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.regex.Pattern;

/**
 * 默认消息处理者实现
 */
@Component("defaultMessageHandler")
@Slf4j
public class MessageHandlerDispatcher implements org.springframework.messaging.MessageHandler, ApplicationContextAware, ApplicationListener<ContextClosedEvent> {

    private static ApplicationContext ctx;

    private static AtomicInteger threadCount = new AtomicInteger(1);

    private static ThreadPoolExecutor executor;

    /**
     * 获取线程
     *
     * @return
     */
    public static ThreadPoolExecutor getExecutor() {
        if (executor == null) {
            synchronized (MessageHandlerDispatcher.class) {
                if (executor == null) {
                    int coreSize = Runtime.getRuntime().availableProcessors() * 2;
                    executor = new ThreadPoolExecutor(coreSize,
                            coreSize * 2,
                            10,
                            TimeUnit.SECONDS,
                            new LinkedBlockingDeque<>(1000 * 10),
                            new ThreadFactory() {
                                @Override
                                public Thread newThread(Runnable r) {
                                    return new Thread(r, "MessageHandlerDispatcher-Thread-" + threadCount.getAndIncrement());
                                }
                            },
                            new ThreadPoolExecutor.DiscardOldestPolicy());
                }
            }
        }
        return executor;
    }

    /**
     * 停止线程池
     */
    public static void shutdownExecutor() {
        ThreadPoolExecutor executor = getExecutor();
        executor.shutdown();
        try {
            executor.awaitTermination(60, TimeUnit.SECONDS);
        } catch (InterruptedException e) {
            log.error("MessageHandlerDispatcher executorService.awaitTermination has error", e);
        }
        executor.shutdownNow();
    }

    @Override
    public void setApplicationContext(ApplicationContext applicationContext) throws BeansException {
        if (Objects.isNull(ctx)) {
            ctx = applicationContext;
        }
    }

    @Override
    public void handleMessage(Message<?> message) throws MessagingException {
        log.info("MessageHandlerDispatcher receive message - {}", message);
        MessageHeaders headers = message.getHeaders();
        Object topic = headers.get(MqttHeaders.RECEIVED_TOPIC);
        if (Objects.isNull(topic) || StringUtils.isBlank(topic.toString())) {
            if (log.isDebugEnabled()) {
                log.debug("MessageHandlerDispatcher ignore topic is empty message", message);
            }
            return;
        }
        String topicName = topic.toString();
        Map<String, Object> beans = ctx.getBeansWithAnnotation(Subscribe.class);
        int count = 0;
        for (String key : beans.keySet()) {
            Object o = beans.get(key);
            if (!(o instanceof MessageHandler)) {
                if (log.isDebugEnabled()) {
                    log.debug("MessageHandlerDispatcher ignore @Subscribe class not of class - {}", MessageHandler.class.getName());
                }
                continue;
            }
            MessageHandler handler = (MessageHandler) o;
            Subscribe subscribe = o.getClass().getDeclaredAnnotation(Subscribe.class);
            if (subscribe == null) {
                continue;
            }
            String subscribeTopic = subscribe.topic();
            if (StringUtils.isBlank(subscribeTopic)) {
                if (log.isDebugEnabled()) {
                    log.debug("MessageHandlerDispatcher ignore @Subscribe class not config topic value - {}", handler.getClass());
                }
                continue;
            }
            subscribeTopic = subscribeTopic.trim();
            Pattern pattern = Pattern.compile("(\\$\\{)(\\w|\\.)+(})");
            if (pattern.matcher(subscribeTopic).matches()) {
                String propertyKey = subscribeTopic.substring(2, subscribeTopic.length() - 1);
                String propertyValue = ctx.getEnvironment().getProperty(propertyKey);
                if (StringUtils.isBlank(propertyValue)) {
                    log.debug("MessageHandlerDispatcher ignore @Subscribe class not config topic value - {}, propertyKey - {}", handler.getClass(), propertyKey);
                    continue;
                }
                subscribeTopic = propertyValue;
            }
            if ("*".equals(subscribeTopic)) {
                submitTask(message, handler);
                count++;
            } else if (subscribeTopic.equals(topicName)) {
                submitTask(message, handler);
                count++;
            } else if (subscribeTopic.contains("*")) {
                String[] topicSplit = subscribeTopic.split("\\*");
                if (topicSplit == null || topicSplit.length != 2) {
                    if (log.isDebugEnabled()) {
                        log.debug("MessageHandlerDispatcher ignore @Subscribe class that topic just support one char '*'");
                    }
                    continue;
                }
                int headPos = topicName.indexOf(topicSplit[0]);
                if (headPos < 0) {
                    continue;
                }
                int rearPos = topicName.lastIndexOf(topicSplit[1]);
                if (rearPos < 0 || rearPos < headPos + topicSplit[0].length()) {
                    continue;
                }
                submitTask(message, handler);
                count++;
            }
        }
        if (count == 0) {
            if (log.isDebugEnabled()) {
                log.debug("MessageHandlerDispatcher not found message handler for message - {}", message);
            }
        }
    }

    /**
     * 提交命令执行线程
     *
     * @param message
     * @param handler
     */
    private void submitTask(Message<?> message, MessageHandler handler) {
        getExecutor().submit(() -> handler.handleMessage(message));
    }

    @Override
    public void onApplicationEvent(ContextClosedEvent contextClosedEvent) {
        log.info("System will exit! Do clean...");
        shutdownExecutor();
        log.info("System do clean done!");
    }
}

import java.lang.annotation.*;

@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
public @interface Subscribe {

    String topic() default "*";

}


        